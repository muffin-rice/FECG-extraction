import numpy as np
from utils2 import scale_signals, generate_gaussian_noise_by_shape, get_random_mfratio, resample_signal_noise_peak, \
    return_peaks, gauss_kernel, correct_peaks
from hyperparams import MF_RATIO, NUM_WINDOWS, MF_RATIO_STD, WINDOW_LENGTH, PEAK_SCALE, PEAK_SIGMA, BINARY_PEAK_WINDOW, NOISE
from math import cos, sqrt, pi, sin
from scipy import signal as ss
from scipy.signal import filtfilt, butter
from torchaudio.functional import bandpass_biquad
from torch import from_numpy

def transform_keys(signal_dict):
    signal_dict['fecg_sig'] = signal_dict['fecg_clean']
    signal_dict['mecg_sig'] = signal_dict['mecg_clean']
    signal_dict['fecg_peaks'] = signal_dict['fecg_peaks'][0].astype(int)
    signal_dict['noise'] = signal_dict['mecg_signal'] - signal_dict['mecg_clean']

def downsample_fecg(signal):
    signal['fecg_sig'] = ss.resample(signal['fecg_sig'][0,:], int(signal['fecg_sig'].shape[1]/2))[np.newaxis,:]

class Filterer:
    def __init__(self, fs = 125, lowcut = 1, highcut = 55, order=3):
        self.fs = fs
        self.lowcut = lowcut
        self.highcut = highcut
        self.order = order

    def perform_filter(self, window):
        nyquist = self.fs/2
        low = self.lowcut / nyquist
        high = self.highcut / nyquist
        b, a = butter(self.order, [low, high], btype='bandpass', analog=False, output='ba')
        window['mecg_sig'] = filtfilt(b, a, window['mecg_sig'])

def calc_peak_mask(sig : np.array, peak_window = PEAK_SCALE, peak_sigma = PEAK_SIGMA,
                   binary_peak_window = BINARY_PEAK_WINDOW, actual_peaks = None):
    # signal should be single channel; 1 x sig_length

    if actual_peaks is None:
        peaks = correct_peaks(return_peaks(sig), sig, window_radius=5)
    else:
        peaks = correct_peaks(actual_peaks, sig, window_radius=5)

    peak_mask = np.zeros(sig.shape)

    binary_peak_mask = np.zeros(sig.shape)

    for peak in peaks:
        peak = int(peak)
        if peak >= WINDOW_LENGTH*NUM_WINDOWS:
            break
        left, right = peak-int(peak_window/2), peak+int(peak_window/2)+1
        peak_mask[left : right] = gauss_kernel(peak_window, peak_sigma)[:len(peak_mask[left : right])]

        binary_peak_mask[peak] = 1

    return peak_mask, binary_peak_mask

def calc_multi_channel_peak_mask(sig : np.ndarray, peak_window = PEAK_SCALE, peak_sigma = PEAK_SIGMA, actual_peaks = None):
    mask = np.zeros(sig.shape)
    binary_peak_mask = np.zeros(sig.shape)

    for channel in range(sig.shape[0]):
        mask[channel, :], binary_peak_mask[channel, :] = calc_peak_mask(sig[channel, :], peak_window, peak_sigma,
                                                                        actual_peaks=actual_peaks)

    return mask, binary_peak_mask

def get_bad_keys(d):
    # returns the keys that should be removed from the loadmat
    keys_to_remove = []
    for k, v in d.items():
        if type(v) != np.ndarray or 'file' in k or 'fname' in k:
            keys_to_remove.append(k)
        else:
            d[k] = v.astype(np.float32)

    return keys_to_remove

def remove_bad_keys(signal):
    '''remove the irrelevant keys generated by scipy's loadmat'''
    for key in get_bad_keys(signal):
        signal.pop(key)

class Resampler:
    '''re-scales (time-wise) by a random number between the boundary set by ratio'''
    def __init__(self, desired_length = 500, shape_index=1, ratio=(0.84, 1.16), offset=50):
        self.desired_length = desired_length
        self.shape_index = shape_index
        self.ratio = ratio
        self.offset = offset

    def perform_initial_trim(self, signal):
        '''trim if necessary to reduce computational load on resampling'''
        trim_length = int(self.desired_length * 1.5+self.offset)
        if signal['mecg_sig'].shape[self.shape_index] < trim_length:
            return

        # TODO: change if statement handling
        if self.shape_index == 1:
            signal['mecg_sig'] = signal['mecg_sig'][:,self.offset:trim_length]
            signal['fecg_sig'] = signal['fecg_sig'][:,self.offset:trim_length]
            signal['noise'] = signal['noise'][:,self.offset:trim_length]
            signal['fecg_peaks'] = signal['fecg_peaks'][(signal['fecg_peaks'] < trim_length) &
                                                        (self.offset < signal['fecg_peaks'])].astype(int) - self.offset
        else:
            raise NotImplementedError

    def resample_signal(self, signal):
        signal['mecg_sig'], _, _ = resample_signal_noise_peak(signal['mecg_sig'], ratio=self.ratio,
                                                              desired_length=self.desired_length,
                                                              shape_index=self.shape_index)
        # TODO: separate noise for mecg and fecg

        signal['fecg_sig'], signal['noise'], signal['fecg_peaks'] = resample_signal_noise_peak(signal['fecg_sig'], ratio=self.ratio,
                                                                                 peak=signal['fecg_peaks'],
                                                                                 noise=signal['noise'],
                                                                                 desired_length=self.desired_length,
                                                                                 shape_index=self.shape_index)

        return signal


def get_signal_masks(signal):
    '''create masks of the mecg and fecg signals'''
    signal['fetal_mask'], signal['binary_fetal_mask'] = calc_multi_channel_peak_mask(signal['fecg_sig'],
                                                                                     actual_peaks=signal[
                                                                                         'fecg_peaks'])
    signal['maternal_mask'], signal['binary_maternal_mask'] = calc_multi_channel_peak_mask(signal['mecg_sig'])


def split_signal_into_segments(signal):
    '''reshape signal into n_segments x segment for individual scaling'''

    signal['mecg_sig'] = signal['mecg_sig'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['fecg_sig'] = signal['fecg_sig'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['binary_fetal_mask'] = signal['binary_fetal_mask'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['fetal_mask'] = signal['fetal_mask'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['binary_maternal_mask'] = signal['binary_maternal_mask'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['maternal_mask'] = signal['maternal_mask'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['noise'] = signal['noise'].reshape(NUM_WINDOWS, WINDOW_LENGTH)


def check_signal_shapes(signal):
    '''ensure fecg and mecg shapes match'''
    assert signal['fetal_mask'].shape == signal['maternal_mask'].shape


def check_nans(segment):
    '''ensure no nans'''
    assert not (np.isnan(segment['fecg_sig']).any() or np.isnan(
        segment['mecg_sig']).any()), f'Signals are nan {segment}'


def add_noise_signal(signal):
    '''adds a gaussian noise (random) '''
    signal['noise'] += generate_gaussian_noise_by_shape(shape=signal['fecg_sig'].shape, stdev=NOISE).numpy()


def scale_segment(segment, mf_ratio=None):
    '''scales the segment'''
    # scale and normalize segment['fecg_sig'] and segment['mecg_sig']
    if mf_ratio is None:
        mf_ratio = get_random_mfratio(MF_RATIO, MF_RATIO_STD)

    segment['mf_ratio'] = mf_ratio

    segment['mecg_sig'], segment['fecg_sig'], segment['offset'] = scale_signals(segment['mecg_sig'],
                                                                                segment['fecg_sig'], mf_ratio,
                                                                                segment['noise'])



def scale_multiple_segments(signal):
    '''scales multiple segments'''
    mf_ratio = get_random_mfratio(MF_RATIO, MF_RATIO_STD)
    signal['offset'] = np.zeros_like(signal['mecg_sig'])
    signal['mf_ratio'] = mf_ratio
    for i in range(NUM_WINDOWS):
        signal['mecg_sig'][i, :], signal['fecg_sig'][i, :], signal['offset'][i, :] = scale_signals(
            signal['mecg_sig'][[i], :],
            signal['fecg_sig'][[i], :], mf_ratio,
            signal['noise'][[i], :])