import numpy as np
from utils2 import scale_signals, generate_gaussian_noise_by_shape, get_random_mfratio, resample_signal_noise_peak, \
    return_peaks, gauss_kernel, correct_peaks
from hyperparams import MF_RATIO, NUM_WINDOWS, MF_RATIO_STD, WINDOW_LENGTH, PEAK_SCALE, PEAK_SIGMA, BINARY_PEAK_WINDOW, NOISE

def transform_keys(signal_dict):
    signal_dict['fecg_sig'] = signal_dict['fecg_clean']
    signal_dict['mecg_sig'] = signal_dict['mecg_clean']
    signal_dict['fecg_peaks'] = signal_dict['fecg_peaks'][0]
    signal_dict['noise'] = signal_dict['mecg_signal'] - signal_dict['mecg_clean']

def calc_peak_mask(sig : np.array, peak_window = PEAK_SCALE, peak_sigma = PEAK_SIGMA,
                   binary_peak_window = BINARY_PEAK_WINDOW, actual_peaks = None):
    # signal should be single channel; 1 x sig_length

    if actual_peaks is None:
        peaks = correct_peaks(return_peaks(sig), sig, window_len=3)
    else:
        peaks = correct_peaks(actual_peaks, sig, window_len=3)

    peak_mask = np.zeros(sig.shape)

    binary_peak_mask = np.zeros(sig.shape)

    for peak in peaks:
        peak = int(peak)
        if peak >= 500:
            break
        left, right = peak-int(peak_window/2), peak+int(peak_window/2)+1
        peak_mask[left : right] = gauss_kernel(peak_window, peak_sigma)[:len(peak_mask[left : right])]

        binary_peak_mask[peak] = 1

        # if peak < binary_peak_window:
        #     binary_peak_mask[0:peak+binary_peak_window]= 1
        # elif peak + binary_peak_window >= binary_peak_mask.shape[0]:
        #     binary_peak_mask[peak-binary_peak_window:] = 1
        # else:
        #     binary_peak_mask[peak-binary_peak_window:peak+binary_peak_window] = 1

    return peak_mask, binary_peak_mask

def calc_multi_channel_peak_mask(sig : np.ndarray, peak_window = PEAK_SCALE, peak_sigma = PEAK_SIGMA, actual_peaks = None):
    mask = np.zeros(sig.shape)
    binary_peak_mask = np.zeros(sig.shape)

    for channel in range(sig.shape[0]):
        mask[channel, :], binary_peak_mask[channel, :] = calc_peak_mask(sig[channel, :], peak_window, peak_sigma,
                                                                        actual_peaks=actual_peaks)

    return mask, binary_peak_mask

def get_bad_keys(d):
    # returns the keys that should be removed from the loadmat
    keys_to_remove = []
    for k, v in d.items():
        if type(v) != np.ndarray or 'file' in k or 'fname' in k:
            keys_to_remove.append(k)
        else:
            d[k] = v.astype(np.float32)

    return keys_to_remove

def remove_bad_keys(signal):
    '''remove the irrelevant keys generated by scipy's loadmat'''
    for key in get_bad_keys(signal):
        signal.pop(key)

class Resampler:
    '''create additional class to store length and other parameters'''
    def __init__(self, desired_length = 500, shape_index=1, ratio=(0.84, 1.16)):
        self.desired_length = desired_length
        self.shape_index = shape_index
        self.ratio = ratio

    def perform_initial_trim(self, signal):
        '''trim if necessary to reduce computational load on resampling'''
        trim_length = int(self.desired_length * 1.5)
        if signal['mecg_sig'].shape[self.shape_index] < trim_length:
            return

        # TODO: change if statement handling
        if self.shape_index == 1:
            signal['mecg_sig'] = signal['mecg_sig'][:,:trim_length]
            signal['fecg_sig'] = signal['fecg_sig'][:,:trim_length]
            signal['noise'] = signal['noise'][:,:trim_length]
            signal['fecg_peaks'] = signal['fecg_peaks'][signal['fecg_peaks'] < trim_length]
        else:
            raise NotImplementedError

    def resample_signal(self, signal):
        signal['mecg_sig'], _, _ = resample_signal_noise_peak(signal['mecg_sig'], ratio=self.ratio,
                                                              desired_length=self.desired_length,
                                                              shape_index=self.shape_index)
        # TODO: separate noise for mecg and fecg

        signal['fecg_sig'], signal['noise'], signal['fecg_peaks'] = resample_signal_noise_peak(signal['fecg_sig'], ratio=self.ratio,
                                                                                 peak=signal['fecg_peaks'],
                                                                                 noise=signal['noise'],
                                                                                 desired_length=self.desired_length,
                                                                                 shape_index=self.shape_index)

        return signal


def get_signal_masks(signal):
    '''create masks of the mecg and fecg signals'''
    signal['fetal_mask'], signal['binary_fetal_mask'] = calc_multi_channel_peak_mask(signal['fecg_sig'],
                                                                                     actual_peaks=signal[
                                                                                         'fecg_peaks'])
    signal['maternal_mask'], signal['binary_maternal_mask'] = calc_multi_channel_peak_mask(signal['mecg_sig'])


def split_signal_into_segments(signal):
    '''reshape signal into n_segments x segment for individual scaling'''
    signal['mecg_sig'] = signal['mecg_sig'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['fecg_sig'] = signal['fecg_sig'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['binary_fetal_mask'] = signal['binary_fetal_mask'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['fetal_mask'] = signal['fetal_mask'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['binary_maternal_mask'] = signal['binary_maternal_mask'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['maternal_mask'] = signal['maternal_mask'].reshape(NUM_WINDOWS, WINDOW_LENGTH)
    signal['noise'] = signal['noise'].reshape(NUM_WINDOWS, WINDOW_LENGTH)


def check_signal_shapes(signal):
    '''ensure fecg and mecg shapes match'''
    assert signal['fetal_mask'].shape == signal['maternal_mask'].shape


def check_nans(segment):
    '''ensure no nans'''
    assert not (np.isnan(segment['fecg_sig']).any() or np.isnan(
        segment['mecg_sig']).any()), f'Signals are nan {segment}'


def add_noise_signal(signal):
    '''adds a gaussian noise (random) '''
    signal['noise'] += generate_gaussian_noise_by_shape(shape=signal['fecg_sig'].shape, stdev=NOISE).numpy()


def scale_segment(segment, mf_ratio=None):
    '''scales the segment'''
    # scale and normalize segment['fecg_sig'] and segment['mecg_sig']
    if mf_ratio is None:
        mf_ratio = get_random_mfratio(MF_RATIO, MF_RATIO_STD)

    segment['mecg_sig'], segment['fecg_sig'], segment['offset'] = scale_signals(segment['mecg_sig'],
                                                                                segment['fecg_sig'], mf_ratio,
                                                                                segment['noise'])

    return segment['mecg_sig'], segment['fecg_sig'], segment['offset']


def scale_multiple_segments(signal):
    '''scales multiple segments'''
    mf_ratio = get_random_mfratio(MF_RATIO, MF_RATIO_STD)
    signal['offset'] = np.zeros_like(signal['mecg_sig'])
    for i in range(NUM_WINDOWS):
        signal['mecg_sig'][i, :], signal['fecg_sig'][i, :], signal['offset'][i, :] = scale_signals(
            signal['mecg_sig'][[i], :],
            signal['fecg_sig'][[i], :], mf_ratio,
            signal['noise'][[i], :])